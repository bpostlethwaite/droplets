{"ts":1341508980327,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*jshint asi: true*/\n/*jshint laxcomma: true*/\n\"use strict\";\nvar field = require(\"../public/wavefield.gen.js\")()\nvar printarr = require(\"../printArray.js\")\n\n\nfield.setResolution(200, 200)\nvar i\n  , start = Date.now()\nfor (i = 0; i < 2; i++) {\n  var u = field.update()\n}\nconsole.log(Date.now() - start)\nprintarr( u , 7)\n//console.log( u[50] )\nconsole.log('')\n\n\n\n/*\nvar coeffs = [\n    [0.0, -1.0, 0.0]\n  , [-1.0, 4.0, -1.0]\n  , [0.0, -1.0, 0.0]\n]\n\nvar m = 100\n, n = 150\n\nvar A = Array.matrix(m, n, 1.1)\n\nvar C = [\n    [1.3, 2.3, 3.3, 4.3, 5.3, 4.3]\n  , [6.3, 7.3, 8.3, 9.3, 1.3, 3.3]\n  , [1.3, 2.3, 3.3, 4.3, 5.3, 2.3]\n  , [6.3, 7.3, 8.3, 9.3, 1.3, 7.3]\n  , [1.0, 2.0, 3.0, 4.0, 5.0, 1.0]\n  , [6.0, 7.0, 8.0, 9.0, 1.0, 1.0]\n]\n\nvar C0 = [\n    [0.0, 0.0, 0.0 ,0.0, 0.0, 0.0, 0.0, 0.0]\n  , [0.0, 1.3, 2.3, 3.3, 4.3, 5.3, 4.3, 0.0]\n  , [0.0, 6.3, 7.3, 8.3, 9.3, 1.3, 3.3, 0.0]\n  , [0.0, 1.3, 2.3, 3.3, 4.3, 5.3, 2.3, 0.0]\n  , [0.0, 6.3, 7.3, 8.3, 9.3, 1.3, 7.3, 0.0]\n  , [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 1.0, 0.0]\n  , [0.0, 6.0, 7.0, 8.0, 9.0, 1.0, 1.0, 0.0]\n  , [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n]\n\n\nfield.setResolution(m, n)\nvar i\nfor( i = 0; i < 2000; i++) {\n  A = field.conv2(A, coeffs)\n\n}\n\n//printarr(C, 6 )\nconsole.log(A[50])\nconsole.log('')\n\n\n\nArray.matrix = function (m , n, initial) {\n  // Array extender function adds capability\n  // of initializing 2D matrices of mxn size\n  // to default value = initial\n  var a, i , j, mat = []\n  for (i = 0; i < m; i += 1) {\n    a = []\n    for (j = 0; j < n; j += 1) {\n      a[j] = initial\n    }\n    mat[i] = a\n  }\n  return mat\n}\n\n\n\n// ALTERNATE CONV2 TRIALS\n/*\n  function conv2(u, dum1, kernel, rows, cols, k, K) {\n  // u is data array, dum is a predefined array for out data\n  // kernel is the convolution kernel\n  // rows and cols are the max data dimensions\n  // k is the kxk kernel dimension and K is 1/2 * k\n  var i, ii, j, jj, m, mm, sum, n, nn\n  for(i=0; i < rows; ++i) {      // rows\n    for(j=0; j < cols; ++j) {    // columns\n      sum = 0                    // init to 0 before sum\n      for(m=0; m < k; ++m) {     // kernel rows\n        mm = k - 1 - m           // row index of flipped kernel\n        for(n=0; n < k; ++n) {   // kernel columns\n          nn = k - 1 - n         // column index of flipped kernel\n          // index of input signal, used for checking boundary\n          ii = i + (m - K)\n          jj = j + (n - K)\n          // ignore input samples which are out of bound\n          if( ii >= 0 && ii < rows && jj >= 0 && jj < cols )\n            sum += u[ii][jj] * kernel[mm][nn];\n        }\n      }\n      dum1[i][j] = sum\n    }\n  }\n  return dum1\n}\n\n  function conv2(image, kernel, out) {\n    var i, j, ii, jj, data, kern, sum\n    for (i = 1; i < height - 1; ++i) { // iterate through image\n      for (j = 1; j < width - 1; ++j) {\n        sum = 0; // sum will be the sum of input data * coeff terms\n        for (ii = - 1; ii <= 1; ++ii) { // iterate over kernel\n          for (jj = - 1; jj <= 1; ++jj) {\n            data = image[i + ii][j +jj];\n            kern = kernel[ii + 1][jj + 1];\n            sum += data * kern;\n          }\n        }\n        out[i][j] = sum\n      }\n    }\n    return out\n  }\n*/"]],"start1":0,"start2":0,"length1":0,"length2":3171}]],"length":3171}
